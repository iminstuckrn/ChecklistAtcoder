<!DOCTYPE html>
<html>
<head>
  <title>AtCoder Checklist</title>
  <meta charset="UTF-8" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Reset margin cho body ƒë·ªÉ background ph·ªß to√†n m√†n h√¨nh */
    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5; /* Fallback color */
      
      /* --- BACKGROUND CHO BODY (CH·ªåN M·ªòT TRONG C√ÅC C√ÅCH D∆Ø·ªöI) --- */
      /* C√°ch 1: H√¨nh ·∫£nh n·ªÅn (thay ƒë·ªïi ƒë∆∞·ªùng d·∫´n ·∫£nh c·ªßa b·∫°n) */
      background-image: url('https://cdn.pixabay.com/photo/2016/11/29/05/45/abstract-1867623_1280.jpg'); /* V√≠ d·ª• ·∫£nh abstract */
      background-size: cover; /* ƒê·∫£m b·∫£o ·∫£nh ph·ªß k√≠n */
      background-repeat: no-repeat;
      background-attachment: fixed; /* Gi·ªØ c·ªë ƒë·ªãnh ·∫£nh khi cu·ªôn */

      /* C√°ch 2: Gradient n·ªÅn (b·ªè ghi ch√∫ n·∫øu mu·ªën d√πng) */
      /* background-image: linear-gradient(to right bottom, #4CAF50, #2196F3); */
      /* background-size: cover; */
      /* background-repeat: no-repeat; */
      /* background-attachment: fixed; */
    }

    /* L·ªõp t·∫°o hi·ªáu ·ª©ng blur cho background */
    .background-blur {
        position: fixed; /* ƒê·∫∑t c·ªë ƒë·ªãnh */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* K·∫ø th·ª´a background t·ª´ body */
        background-image: inherit; 
        background-size: inherit;
        background-repeat: inherit;
        background-attachment: inherit;
        filter: blur(5px); /* ƒêi·ªÅu ch·ªânh ƒë·ªô blur t·∫°i ƒë√¢y (v√≠ d·ª• 5px) */
        z-index: -1; /* ƒê·∫∑t ph√≠a sau n·ªôi dung ch√≠nh */
    }

    /* Wrapper cho n·ªôi dung ch√≠nh ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng l·ªõp m·ªù n·ªïi b·∫≠t */
    .content-wrapper {
        background-color: rgba(255, 255, 255, 0.8); /* N·ªÅn tr·∫Øng v·ªõi ƒë·ªô trong su·ªët 80% */
        border-radius: 12px;
        padding: 30px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2); /* ƒê·ªï b√≥ng nh·∫π */
        width: 90%; /* Chi·∫øm 90% chi·ªÅu r·ªông body */
        max-width: 960px; /* Gi·ªõi h·∫°n chi·ªÅu r·ªông t·ªëi ƒëa */
        margin: 20px auto; /* CƒÉn gi·ªØa v√† t·∫°o kho·∫£ng c√°ch tr√™n d∆∞·ªõi */
        position: relative; /* ƒê·∫£m b·∫£o n·∫±m tr√™n l·ªõp blur */
        z-index: 1; /* ƒê·∫∑t ph√≠a tr√™n l·ªõp background-blur */
        box-sizing: border-box; /* Bao g·ªìm padding v√† border trong width/height */
    }


    h1 {
      font-size: 28px;
      color: #2c3e50;
      margin-bottom: 30px;
      padding-bottom: 15px;
      border-bottom: 2px solid #3498db;
      text-align: center;
    }

    /* Styles for the new tabbed interface */
    .tab-container {
      display: flex; /* Arrange buttons horizontally */
      margin-bottom: 20px;
      background-color: rgba(224, 224, 224, 0.85); /* Th√™m ƒë·ªô trong su·ªët */
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.08);
    }

    .tab-button {
      flex-grow: 1; /* Distribute space evenly */
      padding: 12px 20px;
      border: none;
      background-color: #cccccc; /* Inactive tab background */
      color: #444; /* Inactive tab text color */
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.3s ease, color 0.3s ease, box-shadow 0.3s ease;
      outline: none; /* Remove outline on focus */
      text-align: center;
    }

    .tab-button:hover:not(.active) {
      background-color: #bbbbbb; /* Slightly darker on hover for inactive tabs */
    }

    .tab-button.active {
      background-color: #3498db; /* Active tab background (blue) */
      color: #ffffff; /* Active tab text color (white) */
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2); /* Inner shadow for active tab */
    }

    /* Optional: Add a subtle border or separator between tabs if desired */
    .tab-button + .tab-button {
        border-left: 1px solid rgba(255, 255, 255, 0.3); /* Subtle separator for active tabs */
    }
    .tab-button:not(.active) + .tab-button:not(.active) {
        border-left: 1px solid #b0b0b0; /* Darker separator for inactive tabs */
    }


    /* Existing problem list styles */
    #problem-list {
      list-style: none;
      padding-left: 0;
      margin-top: 20px; /* Adjust margin if needed after tab bar */
      background-color: rgba(255, 255, 255, 0.7); /* Th√™m ƒë·ªô trong su·ªët */
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.08);
    }

    #problem-list li {
      display: flex;
      align-items: center;
      padding: 15px 20px;
      border-bottom: 1px solid #ecf0f1;
      gap: 15px; /* Kho·∫£ng c√°ch gi·ªØa c√°c c·ªôt */
      transition: background-color 0.3s ease, transform 0.3s ease;
    }

    #problem-list li:last-child {
      border-bottom: none;
    }

    #problem-list li:hover {
      background-color: #f8f9fa;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    /* Style cho c·ªôt s·ªë th·ª© t·ª± */
    .problem-number-column {
        width: 30px; /* Chi·ªÅu r·ªông c·ªë ƒë·ªãnh cho c·ªôt s·ªë th·ª© t·ª± */
        flex-shrink: 0; /* NgƒÉn kh√¥ng cho c·ªôt n√†y co l·∫°i */
        font-weight: bold;
        color: #555;
        text-align: right; /* CƒÉn ph·∫£i s·ªë th·ª© t·ª± */
    }

    /* Style cho dropdown tr·∫°ng th√°i */
    .problem-status-select {
        padding: 8px 12px;
        border: 1px solid #ccc;
        border-radius: 5px;
        font-size: 14px;
        background-color: #f9f9f9;
        cursor: pointer;
        outline: none;
        flex-shrink: 0; /* NgƒÉn kh√¥ng cho n√≥ co l·∫°i */

        /* --- C·∫¨P NH·∫¨T ƒê·ªÇ XO√Å M≈®I T√äN --- */
        -webkit-appearance: none; /* For Chrome, Safari, Opera */
        -moz-appearance: none;    /* For Firefox */
        appearance: none;         /* Standard property */
        background-image: none;   /* Lo·∫°i b·ªè h√¨nh n·ªÅn m≈©i t√™n m·∫∑c ƒë·ªãnh */
        padding-right: 12px;      /* ƒêi·ªÅu ch·ªânh padding n·∫øu c·∫ßn */
        /* --- K·∫æT TH√öC C·∫¨P NH·∫¨T --- */
    }

    .problem-status-select:focus {
        border-color: #3498db;
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }

    .problem-info {
      display: flex;
      flex-grow: 1;
      justify-content: space-between; /* Gi√£n c√°ch c√°c th√†nh ph·∫ßn con */
      align-items: center;
      flex-wrap: wrap;
    }

    /* Styles cho icon tr·∫°ng th√°i */
    .problem-status-icon {
        margin-right: 8px; /* Kho·∫£ng c√°ch v·ªõi text */
        font-size: 1.2em; /* K√≠ch th∆∞·ªõc icon */
        vertical-align: middle; /* CƒÉn ch·ªânh v·ªõi text */
        width: 20px; /* ƒê·∫£m b·∫£o ƒë·ªô r·ªông c·ªë ƒë·ªãnh ƒë·ªÉ cƒÉn ch·ªânh t·ªët */
        text-align: center;
        flex-shrink: 0; /* NgƒÉn icon b·ªã co l·∫°i */
    }

    .problem-title {
      font-size: 17px;
      font-weight: 500;
      color: #34495e;
      text-decoration: none;
    }

    .problem-title:hover {
      text-decoration: underline;
      color: #2980b9;
    }

    .problem-difficulty {
      font-size: 14px;
      color: #7f8c8d;
      font-weight: 400;
      margin-left: 10px;
      flex-shrink: 0;
    }

    /* C√°c l·ªõp tr·∫°ng th√°i cho th·∫ª li */
    li.status-ac {
        background-color: rgba(144, 238, 144, 0.5); /* LightGreen v·ªõi ƒë·ªô trong su·ªët */
    }
    li.status-ac .problem-title {
        text-decoration: line-through;
        color: #28a745; /* M√†u xanh l√° ƒë·∫≠m h∆°n */
    }
    li.status-ac .problem-status-icon { color: #28a745; }

    li.status-wa {
        background-color: rgba(255, 99, 71, 0.5); /* Tomato v·ªõi ƒë·ªô trong su·ªët */
    }
    li.status-wa .problem-title {
        color: #dc3545; /* M√†u ƒë·ªè */
    }
    li.status-wa .problem-status-icon { color: #dc3545; }

    li.status-tle {
        background-color: rgba(255, 215, 0, 0.5); /* Gold v·ªõi ƒë·ªô trong su·ªët */
    }
    li.status-tle .problem-title {
        color: #ffc107; /* M√†u v√†ng cam */
    }
    li.status-tle .problem-status-icon { color: #ffc107; }

    li.status-mle {
        background-color: rgba(173, 216, 230, 0.5); /* LightBlue v·ªõi ƒë·ªô trong su·ªët */
    }
    li.status-mle .problem-title {
        color: #007bff; /* M√†u xanh d∆∞∆°ng */
    }
    li.status-mle .problem-status-icon { color: #007bff; }

    li.status-re {
        background-color: rgba(255, 160, 122, 0.5); /* LightSalmon v·ªõi ƒë·ªô trong su·ªët */
    }
    li.status-re .problem-title {
        color: #fd7e14; /* M√†u cam ƒë·∫≠m */
    }
    li.status-re .problem-status-icon { color: #fd7e14; }

    li.status-ce {
        background-color: rgba(192, 192, 192, 0.5); /* Silver v·ªõi ƒë·ªô trong su·ªët */
    }
    li.status-ce .problem-title {
        color: #6c757d; /* M√†u x√°m */
    }
    li.status-ce .problem-status-icon { color: #6c757d; }

    li.status-other {
        background-color: rgba(220, 220, 220, 0.5); /* Gainsboro v·ªõi ƒë·ªô trong su·ªët */
    }
    li.status-other .problem-title {
        color: #343a40; /* M√†u ƒëen x√°m */
    }
    li.status-other .problem-status-icon { color: #343a40; }

    li.status-unsolved { /* M·∫∑c ƒë·ªãnh */
        background-color: transparent; /* Kh√¥ng m√†u n·ªÅn */
    }
    li.status-unsolved .problem-title {
        color: #34495e; /* M√†u m·∫∑c ƒë·ªãnh */
        text-decoration: none;
    }
    li.status-unsolved .problem-status-icon { color: #6c757d; } /* M√†u x√°m cho icon */


    /* Style cho bi·ªÉu ƒë·ªì tr√≤n */
    #solvedPieChart {
        background-color: rgba(255, 255, 255, 0.7); /* Th√™m background trong su·ªët cho canvas */
        border-radius: 8px;
        padding: 10px;
        margin: 20px auto;
        display: block; /* ƒê·ªÉ cƒÉn gi·ªØa block element */
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.08);
    }
  </style>
</head>
<body>
  <div class="background-blur"></div>

  <div class="content-wrapper">
    <h1>‚û°Ô∏è AtCoder Checklist</h1>

    <div class="tab-container">
      <button class="tab-button active" data-difficulty="Easy">Easy</button>
      <button class="tab-button" data-difficulty="Medium">Medium</button>
      <button class="tab-button" data-difficulty="Hard">Hard</button>
    </div>

    <div style="width: 300px; margin: 20px auto;">
      <canvas id="solvedPieChart"></canvas>
    </div>

    <ul id="problem-list"></ul>
  </div>

  <script>
    // Khai b√°o bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u instance c·ªßa Chart, gi√∫p c·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì sau n√†y
    let myPieChart;

    // H√†m tr·∫£ v·ªÅ k√Ω t·ª± Unicode cho t·ª´ng tr·∫°ng th√°i
    function getIconForStatus(status) {
        switch (status) {
            case 'AC': return '&#x2705;'; // ‚úÖ White Heavy Check Mark
            case 'WA': return '&#x274C;'; // ‚ùå Cross Mark
            case 'TLE': return '&#x23F1;'; // ‚è±Ô∏è Stopwatch
            case 'MLE': return '&#x1F4BE;'; // üíæ Floppy Disk
            case 'RE': return '&#x26A0;'; // ‚ö†Ô∏è Warning Sign
            case 'CE': return '&#x1F4BB;'; // üíª Personal Computer
            case 'Other': return '&#x2753;'; // ‚ùì Question Mark
            case 'Unsolved': return '&#x25CB;'; // ‚ö™ White Circle
            default: return '';
        }
    }

    async function loadProblems() {
      let problems = [];

      try {
        const [easyData, mediumData, hardData] = await Promise.all([
          fetch('problemlist_easy.json')
            .then(r => r.ok ? r.json() : [])
            .catch(error => {
                console.warn("C·∫£nh b√°o: Kh√¥ng th·ªÉ t·∫£i problemlist_easy.json. Vui l√≤ng ki·ªÉm tra file.", error);
                return [];
            }),
          fetch('problemlist_medium.json')
            .then(r => r.ok ? r.json() : [])
            .catch(error => {
                console.warn("C·∫£nh b√°o: Kh√¥ng th·ªÉ t·∫£i problemlist_medium.json. Vui l√≤ng ki·ªÉm tra file.", error);
                return [];
            }),
          fetch('problemlist_hard.json')
            .then(r => r.ok ? r.json() : [])
            .catch(error => {
                console.warn("C·∫£nh b√°o: Kh√¥ng th·ªÉ t·∫£i problemlist_hard.json. File c√≥ th·ªÉ b·ªã thi·∫øu ho·∫∑c c√≥ l·ªói.", error);
                return [];
            })
        ]);

        let allRawProblems = [];

        // X·ª≠ l√Ω c√°c b√†i to√°n Easy (s·ª≠ d·ª•ng tr∆∞·ªùng 'title')
        easyData.forEach(p => {
            allRawProblems.push({
                title: p.title,
                url: p.url,
                difficulty: p.difficulty
            });
        });

        // X·ª≠ l√Ω c√°c b√†i to√°n Medium (s·ª≠ d·ª•ng tr∆∞·ªùng 'name')
        mediumData.forEach(p => {
            allRawProblems.push({
                title: p.name, // S·ª≠ d·ª•ng 'name' t·ª´ medium.json
                url: p.url,
                difficulty: p.difficulty
            });
        });

        // X·ª≠ l√Ω c√°c b√†i to√°n Hard (s·ª≠ d·ª•ng tr∆∞·ªùng 'name')
        hardData.forEach(p => {
            allRawProblems.push({
                title: p.name || p.title || `Problem ${allRawProblems.length + 1}`, // S·ª≠ d·ª•ng 'name' ho·∫∑c 'title' t·ª´ hard.json
                url: p.url,
                difficulty: p.difficulty
            });
        });

        // G√°n ID duy nh·∫•t cho m·ªói b√†i to√°n trong danh s√°ch t·ªïng h·ª£p
        problems = allRawProblems.map((p, index) => ({
            ...p,
            id: index + 1
        }));

      } catch (error) {
        console.error("L·ªói nghi√™m tr·ªçng khi t·∫£i c√°c b√†i to√°n:", error);
        document.getElementById('problem-list').innerHTML =
          '<li>L·ªói khi t·∫£i b√†i to√°n. Vui l√≤ng ƒë·∫£m b·∫£o c√°c file JSON (v√≠ d·ª•: `problemlist_easy.json`, `problemlist_medium.json`, `problemlist_hard.json`) n·∫±m c√πng th∆∞ m·ª•c v√† b·∫°n ƒëang ch·∫°y m·ªôt m√°y ch·ªß web c·ª•c b·ªô (v√≠ d·ª•: Live Server trong VS Code ho·∫∑c `python -m http.server`).</li>';
        return;
      }

      const list = document.getElementById('problem-list');
      const tabButtons = document.querySelectorAll('.tab-button'); // L·∫•y t·∫•t c·∫£ c√°c n√∫t tab
      // --- ƒê√£ thay ƒë·ªïi m·∫∑c ƒë·ªãnh t·ª´ 'All' sang 'Easy' ---
      let currentFilterDifficulty = 'Easy'; 

      // Th√™m s·ª± ki·ªán click cho m·ªói n√∫t tab
      tabButtons.forEach(button => {
          button.addEventListener('click', () => {
              // X√≥a l·ªõp 'active' kh·ªèi t·∫•t c·∫£ c√°c n√∫t
              tabButtons.forEach(btn => btn.classList.remove('active'));
              // Th√™m l·ªõp 'active' v√†o n√∫t v·ª´a ƒë∆∞·ª£c click
              button.classList.add('active');
              // C·∫≠p nh·∫≠t gi√° tr·ªã l·ªçc hi·ªán t·∫°i
              currentFilterDifficulty = button.dataset.difficulty;
              // G·ªçi h√†m render ƒë·ªÉ c·∫≠p nh·∫≠t danh s√°ch
              render();
              // C·∫≠p nh·∫≠t th·ªëng k√™/bi·ªÉu ƒë·ªì khi l·ªçc thay ƒë·ªïi
              updateStats();
          });
      });

      function render() {
        list.innerHTML = '';
        const selectedDifficulty = currentFilterDifficulty; // S·ª≠ d·ª•ng gi√° tr·ªã t·ª´ tab ƒë∆∞·ª£c ch·ªçn

        // L·ªçc b√†i to√°n tr∆∞·ªõc khi hi·ªÉn th·ªã ƒë·ªÉ c√≥ s·ªë th·ª© t·ª± ƒë√∫ng cho filtered problems
        const filteredProblems = problems.filter(p => {
            // --- Logic l·ªçc v·∫´n gi·ªØ nguy√™n, nh∆∞ng 'All' kh√¥ng c√≤n l√† l·ª±a ch·ªçn ---
            return p.difficulty.toLowerCase() === selectedDifficulty.toLowerCase();
        });


        filteredProblems.forEach((p, index) => { // D√πng filteredProblems ƒë·ªÉ render
          const li = document.createElement('li');
          
          // --- TH√äM C·ªòT S·ªê TH·ª® T·ª∞ RI√äNG BI·ªÜT ---
          const problemNumberColumn = document.createElement('span');
          problemNumberColumn.className = 'problem-number-column';
          problemNumberColumn.textContent = `${index + 1}.`; // Hi·ªÉn th·ªã s·ªë th·ª© t·ª±
          li.appendChild(problemNumberColumn);
          // --- K·∫æT TH√öC TH√äM C·ªòT S·ªê TH·ª® T·ª∞ ---

          // --- THAY TH·∫æ CHECKBOX B·∫∞NG DROPDOWN TR·∫†NG TH√ÅI ---
          const statusSelect = document.createElement('select');
          statusSelect.className = 'problem-status-select';
          statusSelect.dataset.problemUrl = p.url; // L∆∞u URL ƒë·ªÉ d·ªÖ d√†ng truy c·∫≠p localStorage

          const statuses = [
              {value: 'Unsolved', text: 'Ch∆∞a gi·∫£i'},
              {value: 'AC', text: 'AC'},
              {value: 'WA', text: 'WA'},
              {value: 'TLE', text: 'TLE'},
              {value: 'MLE', text: 'MLE'},
              {value: 'RE', text: 'RE'},
              {value: 'CE', text: 'CE'},
              {value: 'Other', text: 'Kh√°c'}
          ];

          statuses.forEach(status => {
              const option = document.createElement('option');
              option.value = status.value;
              option.textContent = status.text;
              statusSelect.appendChild(option);
          });

          // L·∫•y tr·∫°ng th√°i ƒë√£ l∆∞u t·ª´ localStorage, m·∫∑c ƒë·ªãnh l√† 'Unsolved'
          const savedStatus = localStorage.getItem(p.url) || 'Unsolved';
          statusSelect.value = savedStatus; // ƒê·∫∑t gi√° tr·ªã ƒë√£ ch·ªçn cho dropdown

          // Th√™m l·ªõp tr·∫°ng th√°i v√†o li ngay khi render
          li.classList.add('status-' + savedStatus.toLowerCase());

          // Event listener cho dropdown tr·∫°ng th√°i
          statusSelect.addEventListener('change', (event) => {
              const newStatus = event.target.value;
              const problemUrl = event.target.dataset.problemUrl;
              localStorage.setItem(problemUrl, newStatus);
              
              // C·∫≠p nh·∫≠t l·ªõp CSS c·ªßa li
              li.className = ''; // X√≥a t·∫•t c·∫£ c√°c l·ªõp tr·∫°ng th√°i c≈©
              li.classList.add('status-' + newStatus.toLowerCase());
              
              // C·∫≠p nh·∫≠t icon
              const currentIconSpan = document.getElementById(`icon-${p.id}`);
              if (currentIconSpan) {
                  currentIconSpan.innerHTML = getIconForStatus(newStatus);
              }

              updateStats(); // C·∫≠p nh·∫≠t th·ªëng k√™/bi·ªÉu ƒë·ªì
          });

          li.appendChild(statusSelect); // Th√™m dropdown v√†o li
          // --- K·∫æT TH√öC THAY TH·∫æ ---

          const problemInfo = document.createElement('div');
          problemInfo.className = 'problem-info';

          // --- TH√äM ICON TR·∫†NG TH√ÅI V√ÄO ƒê√ÇY ---
          const iconSpan = document.createElement('span'); 
          iconSpan.className = 'problem-status-icon';
          iconSpan.id = `icon-${p.id}`; // G√°n ID ƒë·ªÉ d·ªÖ d√†ng c·∫≠p nh·∫≠t
          iconSpan.innerHTML = getIconForStatus(savedStatus); // Thi·∫øt l·∫≠p icon ban ƒë·∫ßu
          problemInfo.appendChild(iconSpan); 
          // --- K·∫æT TH√öC TH√äM ICON ---

          const a = document.createElement('a');
          a.href = p.url;
          a.textContent = p.title; // Ch·ªâ c√≤n ti√™u ƒë·ªÅ, kh√¥ng c√≤n s·ªë th·ª© t·ª± ·ªü ƒë√¢y
          a.target = '_blank';
          a.className = 'problem-title';

          const difficultySpan = document.createElement('span');
          difficultySpan.textContent = `[${p.difficulty}]`;
          difficultySpan.className = 'problem-difficulty';

          problemInfo.appendChild(a);
          problemInfo.appendChild(difficultySpan);

          li.appendChild(problemInfo);
          list.appendChild(li);
        });
      }

      // ----------- H√ÄM C·∫¨P NH·∫¨T TH·ªêNG K√ä/BI·ªÇU ƒê·ªí M·ªöI -----------
      function updateStats() {
        const selectedDifficulty = currentFilterDifficulty;
        // L·ªçc l·∫°i danh s√°ch b√†i to√°n d·ª±a tr√™n tab hi·ªán t·∫°i ƒë·ªÉ t√≠nh th·ªëng k√™
        const problemsForStats = problems.filter(p => {
            // --- Logic l·ªçc ƒë√£ lo·∫°i b·ªè 'All' ---
            return p.difficulty.toLowerCase() === selectedDifficulty.toLowerCase();
        });

        // Kh·ªüi t·∫°o ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ ƒë·∫øm s·ªë l∆∞·ª£ng t·ª´ng tr·∫°ng th√°i
        const statusCounts = {
            'AC': 0,
            'WA': 0,
            'TLE': 0,
            'MLE': 0,
            'RE': 0,
            'CE': 0,
            'Other': 0,
            'Unsolved': 0
        };

        problemsForStats.forEach(p => {
          const status = localStorage.getItem(p.url) || 'Unsolved';
          // TƒÉng s·ªë ƒë·∫øm cho tr·∫°ng th√°i t∆∞∆°ng ·ª©ng
          if (statusCounts.hasOwnProperty(status)) {
              statusCounts[status]++;
          } else {
              // X·ª≠ l√Ω tr∆∞·ªùng h·ª£p tr·∫°ng th√°i kh√¥ng n·∫±m trong danh s√°ch (√≠t kh·∫£ nƒÉng x·∫£y ra n·∫øu dropdown chu·∫©n)
              statusCounts['Other']++;
          }
        });
        
        const totalCount = problemsForStats.length;

        // Chu·∫©n b·ªã d·ªØ li·ªáu cho Chart.js
        const chartLabels = [];
        const chartData = [];
        const chartColors = [];

        // ƒê·ªãnh nghƒ©a m√†u s·∫Øc cho t·ª´ng tr·∫°ng th√°i
        const statusColors = {
            'AC': '#4CAF50',    // Xanh l√° c√¢y
            'WA': '#FF6384',    // ƒê·ªè nh·∫°t
            'TLE': '#FFCE56',   // V√†ng
            'MLE': '#36A2EB',   // Xanh d∆∞∆°ng
            'RE': '#FF9F40',    // Cam
            'CE': '#9966FF',    // T√≠m
            'Other': '#C9CBCF', // X√°m nh·∫°t
            'Unsolved': '#6C757D' // X√°m ƒë·∫≠m (cho ch∆∞a gi·∫£i)
        };

        // L·ªçc ra c√°c tr·∫°ng th√°i c√≥ s·ªë l∆∞·ª£ng > 0 ƒë·ªÉ ch·ªâ hi·ªÉn th·ªã nh·ªØng tr·∫°ng th√°i th·ª±c s·ª± c√≥ b√†i
        for (const status in statusCounts) {
            if (statusCounts[status] > 0) {
                chartLabels.push(`${status} (${statusCounts[status]})`); // V√≠ d·ª•: AC (10)
                chartData.push(statusCounts[status]);
                chartColors.push(statusColors[status]);
            }
        }

        const ctx = document.getElementById('solvedPieChart');
        if (!ctx) {
            console.error("Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠ canvas v·ªõi id 'solvedPieChart'.");
            return;
        }

        // N·∫øu bi·ªÉu ƒë·ªì ƒë√£ t·ªìn t·∫°i, h·ªßy b·ªè n√≥ tr∆∞·ªõc khi t·∫°o m·ªõi
        if (myPieChart) {
          myPieChart.destroy();
        }

        myPieChart = new Chart(ctx, {
          type: 'pie',
          data: {
            labels: chartLabels,
            datasets: [{
              data: chartData,
              backgroundColor: chartColors,
              hoverOffset: 4
            }]
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: 'top',
              },
              title: {
                display: true,
                text: `Th·ªëng k√™ tr·∫°ng th√°i b√†i gi·∫£i (${totalCount} b√†i)`
              }
            }
          }
        });
      }

      // G·ªçi render v√† updateStats l·∫ßn ƒë·∫ßu khi d·ªØ li·ªáu ƒë√£ t·∫£i xong
      render();
      updateStats(); // G·ªçi h√†m c·∫≠p nh·∫≠t th·ªëng k√™ ban ƒë·∫ßu
    }

    loadProblems();
  </script>
</body>
</html>